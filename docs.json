[{"name":"BoardGameFramework","comment":" Types and functions help create remote multiplayer board games\nusing the related framework. See\n[the detailed documentation and example\ncode](https://github.com/niksilver/board-game-framework/tree/master/docs)\nfor a proper introduction.\n\n# Game IDs\nPlayers with the same game ID (on the same server) are playing the same game.\n@docs GameId, gameId, fromGameId, idGenerator\n\n# Server connection\n@docs Server, wsServer, wssServer, withPort, withGameId, Address, toUrlString\n\n# Basic actions: open, send, close\n@docs open, send, close\n\n# Receiving messages\nWe receive envelopes: either messages from other clients, or messages from\nthe server about leavers and joiners, or messages about connectivity.\nAny game messages sent out are encoded into JSON, so we need to say\nhow to decode our application's JSON messages into some suitable Elm type.\n@docs ClientId, Envelope, Connectivity, Error, decode\n","unions":[{"name":"Address","comment":" The address of a game which we can connect to.\n","args":[],"cases":[]},{"name":"Connectivity","comment":" The current connectivity state, received when it changes.\n\n`Connecting` can also be interpretted as \"reconnecting\", because\nif the connection is lost then the underlying JavaScript will try to\nreconnect.\n\n`Disconnected` will only be received if the client explicitly\nasks for the connection to be closed; otherwise if a disconnection\nis detected the JavaScript will be trying to reconnect.\n\nBoth `Connecting` and `Disconnected` mean there isn't a server connection,\nbut `Disconnected` means that the underlying JavaScript isn't attempting to\nchange that.\n","args":[],"cases":[["Connected",[]],["Connecting",[]],["Disconnected",[]]]},{"name":"Envelope","comment":" A message from the server, or the JavaScript connection layer.\nIt may contain a message specific to our application, which we say\nis of type `a`.\nSee [the concepts document](https://github.com/niksilver/board-game-framework/blob/master/docs/concepts.md)\nfor many more details of envelopes.\n\nThe envelopes are:\n* A welcome when our client joins;\n* A receipt containing any message we sent;\n* A message sent by another client peer;\n* Notice of another client joining;\n* Notice of another client leaving;\n* Change of status with the server connection.\n\nThe field names have consistent types and meaning:\n* `me`: our client's own client ID.\n* `others`: the IDs of all other clients currently in the game.\n* `from`: the ID of the client (not us) who sent the message.\n* `to`: the IDs of the clients to whom a message was sent, including us.\n* `joiner`: the ID of a client who has just joined.\n* `leaver`: the ID of a client who has just left.\n* `num`: the ID of the envelope. After a Welcome envelope, nums will\n  be consecutive.\n* `time`: when the envelope was sent, in milliseconds since the epoch.\n* `body`: the application-specific message sent by the client.\n","args":["a"],"cases":[["Welcome",["{ me : BoardGameFramework.ClientId, others : List.List BoardGameFramework.ClientId, num : Basics.Int, time : Basics.Int }"]],["Receipt",["{ me : BoardGameFramework.ClientId, others : List.List BoardGameFramework.ClientId, num : Basics.Int, time : Basics.Int, body : a }"]],["Peer",["{ from : BoardGameFramework.ClientId, to : List.List BoardGameFramework.ClientId, num : Basics.Int, time : Basics.Int, body : a }"]],["Joiner",["{ joiner : BoardGameFramework.ClientId, to : List.List BoardGameFramework.ClientId, num : Basics.Int, time : Basics.Int }"]],["Leaver",["{ leaver : BoardGameFramework.ClientId, to : List.List BoardGameFramework.ClientId, num : Basics.Int, time : Basics.Int }"]],["Connection",["BoardGameFramework.Connectivity"]]]},{"name":"Error","comment":" An error reading the incoming envelope. If an error bubbles up from\nthe JavaScript library, or if the envelope intent is something unexpected,\nthat's a `LowLevel` error. If we can't decode\nthe JSON with the given decoder, that's a `Json` error, with the\nspecific error coming from the `Json.Decode` package.\n","args":[],"cases":[["LowLevel",["String.String"]],["Json",["Json.Decode.Error"]]]},{"name":"GameId","comment":" A game ID represents a game that multiple players can join.\nIt's a string intended to be shared among intended players.\n","args":[],"cases":[]},{"name":"Server","comment":" A board game server.\n","args":[],"cases":[]}],"aliases":[{"name":"ClientId","comment":" The unique ID of any client.\n","args":[],"type":"String.String"}],"values":[{"name":"close","comment":" Close the connection to the game server.\nNot strictly necessary in most cases,\nbecause opening a new connection will automatically close an existing one.\n\n    import BoardGameFramework as BGF\n\n    port outgoing : Enc.Value -> Cmd msg\n\n    -- Close our connection\n    BGF.close outgoing\n","type":"(Json.Encode.Value -> Platform.Cmd.Cmd msg) -> Platform.Cmd.Cmd msg"},{"name":"decode","comment":" Decode an incoming envelope.\nWhen an envelope is sent it is encoded as JSON, so it needs to be\ndecoded when it's received. Our framework\ncan handle most of that, but it needs help when the envelope contains\na message from a client peer (a body), because that's specific to our\napplication.\n\nThe body is said to be of some type `a`,\nso we need to provide a JSON that produces an `a`.\n\nIf the decoding of the envelope is successful we will get an\n`Ok (Envelope a)`. If there is a problem we will get an `Err Error`.\n\nIn this example we expect our envelope body to be a JSON object\ncontaining an `id` field and a `name` field, both of which are strings.\n\n    import Dict exposing (Dict)\n    import Json.Decode as Dec\n    import Json.Encode as Enc\n    import BoardGameFramework as BGF\n\n    -- Raw JSON envelopes come into this port\n    port incoming : (Enc.Value -> msg) -> Sub msg\n\n    type alias Body =\n      { id : BGF.ClientId\n      , name : String\n      }\n\n    type alias MyEnvelope = BGF.Envelope Body\n\n    -- A JSON decoder which transforms our JSON object into a Body.\n    bodyDecoder : Dec.Decoder Body\n    bodyDecoder =\n      Dec.map2\n        Body\n        (Dec.field \"id\" Dec.string)\n        (Dec.field \"name\" Dec.string)\n\n    type Msg =\n      ...\n      | Received (Result BGF.Error MyEnvelope)\n      | ...\n\n    -- Turn some envelope into a Msg which we can handle in our\n    -- usual update function.\n    receive : Enc.Value -> Msg\n    receive v =\n      BGF.decode bodyDecoder v\n      |> Received\n\n    -- We'll use this in our usual main function to subscribe to\n    -- incoming envelopes and process them.\n    subscriptions : Model -> Sub Msg\n    subscriptions model =\n      incoming receive\n\nSo after subscribing to what comes into our port, the sequence is:\nan envelope gets decoded as a `Result BGF.Error MyEnvelope; this\ngets wrapped into an application-specific `Received` type; we will\nhandle that in our usual `update` function.\n","type":"Json.Decode.Decoder a -> Json.Encode.Value -> Result.Result BoardGameFramework.Error (BoardGameFramework.Envelope a)"},{"name":"fromGameId","comment":" Extract the game ID as a string.\n","type":"BoardGameFramework.GameId -> String.String"},{"name":"gameId","comment":" Turn a string into a game ID.\nA good game ID will have a good chance of being unique and wil be easy\nto communicate, especially in URLs.\nThis test passes if it's five to thirty characters long (inclusive)\nand consists of just alphanumerics, dots, dashes, and forward slashes.\n\n    gameId \"pancake-road\"            == Ok ...\n    gameId \"backgammon/pancake-road\" == Ok ...\n    gameId \"#345#\"                   == Err \"Bad characters\"\n    gameId \"road\"                    == Err \"Too short\"\n","type":"String.String -> Result.Result String.String BoardGameFramework.GameId"},{"name":"idGenerator","comment":" A random name generator for game IDs, which will be of the form\n\"_word_-_word_\".\n\nTo create a `Cmd` that generates a random name, we can use code like this:\n\n    import Random\n    import BoardGameFramework as BGF\n\n    -- Make sure our Msg can handle a generated game id\n    Msg =\n      ...\n      | GeneratedGameId BGF.GameId\n      | ...\n\n    -- Our update function\n    update : Msg -> Model -> (Model, Cmd)\n    update msg model =\n      case msg of\n        ... ->\n          -- Generate a game ID\n          ( updatedModel\n          , Random.generate GeneratedGameId BGF.idGenerator\n          )\n\n        GeneratedGameId gameId ->\n          -- Use the generated game ID\n","type":"Random.Generator BoardGameFramework.GameId"},{"name":"open","comment":" Open a connection to server, with a given game ID, via an Elm port.\n\n    import BoardGameFramework as BGF\n\n    port outgoing : Enc.Value -> Cmd msg\n\n    server = BGF.wssServer \"bgf.pigsaw.org\"\n    gameId = BGF.gameId \"notice-handle\"\n\n    -- Open a connection to wss://bgf.pigsaw.org/g/notice-handle\n    BGF.open outgoing server gameId\n","type":"(Json.Encode.Value -> Platform.Cmd.Cmd msg) -> BoardGameFramework.Server -> BoardGameFramework.GameId -> Platform.Cmd.Cmd msg"},{"name":"send","comment":" Send a message to the other clients.\n\nIn this example we'll send a `Body` message to other clients, which\nrequires us defining a JSON encoder for it.\n\n    import BoardGameFramework as BGF\n\n    type alias Body =\n      { id : BGF.ClientId\n      , name : String\n      }\n\n    bodyEncoder : Body -> Enc.Value\n    bodyEncoder body =\n      Enc.object\n      [ (\"id\" , Enc.string body.id)\n      , (\"name\" , Enc.string body.name)\n      ]\n\n    port outgoing : Enc.Value -> Cmd msg\n\n    body =\n      { id = \"123.456\"\n      , name = \"Tango\"\n      }\n\n    -- Send body to the other clients (and we'll get a receipt).\n    BGF.send outgoing bodyEncoder body\n","type":"(Json.Encode.Value -> Platform.Cmd.Cmd msg) -> (a -> Json.Encode.Value) -> a -> Platform.Cmd.Cmd msg"},{"name":"toUrlString","comment":" Turn an `Address` into a URL, expressed as a string.\nThis is useful for debugging, or otherwise seeing what's going on under\nthe hood.\n","type":"BoardGameFramework.Address -> String.String"},{"name":"withGameId","comment":" Create the address of an actual game we can connect to.\n\n    gid1 = gameId \"voter-when\"\n    gid2 = gameId \"poor-modern\"\n\n    wsServer \"localhost\"\n    |> withPort 8080\n    |> withGameId gid1    -- We can join ws://localhost:8080/g/voter-when\n    |> withGameId gid2    -- Changes to  ws://localhost:8080/g/poor-modern\n","type":"BoardGameFramework.GameId -> BoardGameFramework.Server -> BoardGameFramework.Address"},{"name":"withPort","comment":" Explicitly set the port of a server, if we don't want to connect to\nthe default port. The default port is 80 for insecure connections and\n443 for secure connections.\n\n    wsServer \"localhost\" |> withPort 8080    -- ws://localhost:8080\n","type":"Basics.Int -> BoardGameFramework.Server -> BoardGameFramework.Server"},{"name":"wsServer","comment":" Create a `Server` that uses a websocket connection (not a secure\nwebsocket connection). For example\n\n    wsServer \"bgf.pigsaw.org\"\n\nwill allow us to make connections of the form `ws://bgf.pigsaw.org/...`.\n","type":"String.String -> BoardGameFramework.Server"},{"name":"wssServer","comment":" Create a `Server` that uses a secure websocket connection.\nA call of the form\n\n    wssServer \"bgf.pigsaw.org\"\n\nwill allow us to make connections of the form `wss://bgf.pigsaw.org/...`.\n","type":"String.String -> BoardGameFramework.Server"}],"binops":[]}]